"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BoardValidation = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _piece = require("./piece");

var _board = require("./board");

var _pieceValidation = require("./pieceValidation");

/**
	BoardValidation determines viable move options for all pieces
	given the current state of the board. If it's the White sides turn
	to attack, only White piece move options are evaluated (and visa versa).

	BoardValidation is intended to be the 2nd phase of move
	validation that is capable of taking into account factors across pieces
	on the board (and not just the pieces themselves). For example, King
	castle eligibility is determined based on whether or not both the candidate
	King and Rook pieces have not moved and whether or not the path of travel
	for the King would result in the King being placed in check at any
	point during the travel. Individual Piece validation wouldn't be sufficient
	to determine whether or not this move is possible.

	Additionally, isSquareAttacked exists on the BoardValidation object. While
	this method could have easily existed within the PieceValidation object
	I've kept it in BoardValidation so that PieceValidation remains truly
	agnostic of the other pieces on the same board.

	Due to how BoardValidation actually functions, the client only needs to
	instantiate a BoardValidation for the Game and call the start method
	in order to evaluate every Piece's valid move options. There is no need
	to call PieceValidation (and doing so wouldn't give an accurate picture
	of what is possible anyway).
*/
var BoardValidation =
/*#__PURE__*/
function () {
  function BoardValidation(game) {
    (0, _classCallCheck2.default)(this, BoardValidation);
    this.board = game ? game.board : null;
    this.game = game;
  }

  (0, _createClass2.default)(BoardValidation, [{
    key: "evaluateCastle",
    value: function evaluateCastle(validMoves) {
      var getValidSquares = function getValidSquares(sq) {
        var i = 0;

        for (i = 0; i < validMoves.length; i++) {
          if (validMoves[i].src === sq) {
            return validMoves[i].squares;
          }
        }
      },
          interimMove = null,

      /* eslint no-magic-numbers: 0 */
      rank = this.game.getCurrentSide() === _piece.SideType.White ? 1 : 8,
          squares = {
        'a': this.board.getSquare('a', rank),
        'b': this.board.getSquare('b', rank),
        'c': this.board.getSquare('c', rank),
        'd': this.board.getSquare('d', rank),
        'e': this.board.getSquare('e', rank),
        'f': this.board.getSquare('f', rank),
        'g': this.board.getSquare('g', rank),
        'h': this.board.getSquare('h', rank)
      }; // is king eligible


      if (squares.e.piece && squares.e.piece.type === _piece.PieceType.King && squares.e.piece.moveCount === 0 && !this.isSquareAttacked(squares.e)) {
        // is left rook eligible
        if (squares.a.piece && squares.a.piece.type === _piece.PieceType.Rook && squares.a.piece.moveCount === 0) {
          // are the squares between king and rook clear
          if (!squares.b.piece && !squares.c.piece && !squares.d.piece) {
            // when king moves through squares between, is it in check
            interimMove = this.board.move(squares.e, squares.d, true);

            if (!this.isSquareAttacked(squares.d)) {
              interimMove.undo();
              interimMove = this.board.move(squares.e, squares.c, true);

              if (!this.isSquareAttacked(squares.c)) {
                getValidSquares(squares.e).push(squares.c);
              }
            }

            interimMove.undo();
          }
        } // is right rook eligible


        if (squares.h.piece && squares.h.piece.type === _piece.PieceType.Rook && squares.h.piece.moveCount === 0) {
          // are the squares between king and rook clear
          if (!squares.g.piece && !squares.f.piece) {
            // when king moves through squares between, is it in check
            interimMove = this.board.move(squares.e, squares.f, true);

            if (!this.isSquareAttacked(squares.f)) {
              interimMove.undo();
              interimMove = this.board.move(squares.e, squares.g, true);

              if (!this.isSquareAttacked(squares.g)) {
                getValidSquares(squares.e).push(squares.g);
              }
            }

            interimMove.undo();
          }
        }
      }
    }
  }, {
    key: "filterKingAttack",
    value: function filterKingAttack(kingSquare, moves) {
      var filteredMoves = [],
          i = 0,
          isCheck = false,
          n = 0,
          r = null,
          squares = [];

      for (i = 0; i < moves.length; i++) {
        squares = [];

        for (n = 0; n < moves[i].squares.length; n++) {
          // simulate move on the board
          r = this.board.move(moves[i].src, moves[i].squares[n], true); // check if king is attacked

          if (moves[i].squares[n].piece.type !== _piece.PieceType.King) {
            isCheck = this.isSquareAttacked(kingSquare);
          } else {
            isCheck = this.isSquareAttacked(moves[i].squares[n]);
          } // reverse the move


          r.undo();

          if (!isCheck) {
            squares.push(moves[i].squares[n]);
          }
        }

        if (squares && squares.length > 0) {
          filteredMoves.push({
            squares: squares,
            src: moves[i].src
          });
        }
      }

      return filteredMoves;
    }
  }, {
    key: "findAttackers",
    value: function findAttackers(sq) {
      if (!sq || !sq.piece) {
        return {
          attacked: false,
          blocked: false
        };
      }

      var
      /* eslint no-invalid-this: 0 */
      isAttacked = function isAttacked(b, n) {
        var context = {},
            currentSquare = b.getNeighborSquare(sq, n);

        while (currentSquare) {
          context = {
            attacked: currentSquare.piece && currentSquare.piece.side !== sq.piece.side,
            blocked: currentSquare.piece && currentSquare.piece.side === sq.piece.side,
            piece: currentSquare.piece,
            square: currentSquare
          };

          if (context.attacked) {
            // verify that the square is actually attacked
            _pieceValidation.PieceValidation.create(context.piece.type, b).start(currentSquare, setAttacked(context));

            currentSquare = null;
          } else if (context.blocked) {
            currentSquare = null;
          } else {
            currentSquare = b.getNeighborSquare(currentSquare, n);
          }
        }

        return context;
      },
          isAttackedByKnight = function isAttackedByKnight(b, n) {
        var context,
            currentSquare = b.getNeighborSquare(sq, n);
        context = {
          attacked: false,
          blocked: false,
          piece: currentSquare ? currentSquare.piece : currentSquare,
          square: currentSquare
        };

        if (currentSquare && currentSquare.piece && currentSquare.piece.type === _piece.PieceType.Knight) {
          _pieceValidation.PieceValidation.create(_piece.PieceType.Knight, b).start(currentSquare, setAttacked(context));
        }

        return context;
      },
          self = this,
          setAttacked = function setAttacked(c) {
        return function (err, squares) {
          if (!err) {
            var i = 0;

            for (i = 0; i < squares.length; i++) {
              if (squares[i] === sq) {
                c.attacked = true;
                return;
              }
            }
          }

          c.attacked = false;
        };
      };

      return [isAttacked(self.board, _board.NeighborType.Above), isAttacked(self.board, _board.NeighborType.AboveRight), isAttacked(self.board, _board.NeighborType.Right), isAttacked(self.board, _board.NeighborType.BelowRight), isAttacked(self.board, _board.NeighborType.Below), isAttacked(self.board, _board.NeighborType.BelowLeft), isAttacked(self.board, _board.NeighborType.Left), isAttacked(self.board, _board.NeighborType.AboveLeft), // fix for issue #4
      isAttackedByKnight(self.board, _board.NeighborType.KnightAboveRight), isAttackedByKnight(self.board, _board.NeighborType.KnightRightAbove), isAttackedByKnight(self.board, _board.NeighborType.KnightBelowRight), isAttackedByKnight(self.board, _board.NeighborType.KnightRightBelow), isAttackedByKnight(self.board, _board.NeighborType.KnightBelowLeft), isAttackedByKnight(self.board, _board.NeighborType.KnightLeftBelow), isAttackedByKnight(self.board, _board.NeighborType.KnightAboveLeft), isAttackedByKnight(self.board, _board.NeighborType.KnightLeftAbove)].filter(function (result) {
        return result.attacked;
      });
    }
  }, {
    key: "isSquareAttacked",
    value: function isSquareAttacked(sq) {
      return this.findAttackers(sq).length !== 0;
    }
  }, {
    key: "start",
    value: function start(callback) {
      var _this = this;

      // ensure callback is set
      callback = callback || function (err, validMoves) {
        return new _promise.default(function (resolve, reject) {
          if (err) {
            return reject(err);
          }

          return resolve(validMoves);
        });
      };

      var i = 0,
          kingSquare = null,
          setValidMoves = function setValidMoves(v, sq) {
        return function (err, squares) {
          if (err) {
            return callback(err);
          }

          if (squares && squares.length > 0) {
            v.push({
              squares: squares,
              src: sq
            });
          }
        };
      },
          squares = [],
          validMoves = [];

      if (this.board) {
        // get squares with pieces for which to evaluate move options
        squares = this.board.getSquares(this.game.getCurrentSide());

        for (i = 0; i < squares.length; i++) {
          // set king to refer to later
          if (squares[i].piece.type === _piece.PieceType.King) {
            kingSquare = squares[i];
          }

          if (squares[i] && squares[i].piece) {
            _pieceValidation.PieceValidation.create(squares[i].piece.type, this.board).start(squares[i], setValidMoves(validMoves, squares[i]));
          }
        } // perform king castle validation


        this.evaluateCastle(validMoves); // make sure moves only contain escape & non-check options

        validMoves = this.filterKingAttack(kingSquare, validMoves); // find any pieces attacking the king

        this.findAttackers(kingSquare).forEach(function (attacker) {
          _this.game.emit('check', {
            attackingSquare: attacker.square,
            kingSquare: kingSquare
          });
        });
      } else {
        return callback(new Error('board is invalid'));
      }

      return callback(null, validMoves);
    }
  }], [{
    key: "create",
    value: function create(game) {
      return new BoardValidation(game);
    }
  }]);
  return BoardValidation;
}();

exports.BoardValidation = BoardValidation;
var _default = {
  BoardValidation: BoardValidation
};
exports.default = _default;
//# sourceMappingURL=boardValidation.js.map
