"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Board = exports.NeighborType = void 0;

var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/parse-int"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _piece = require("./piece");

var _events = require("events");

var _square = require("./square");

/**
	The Board is the representation of the current position of the pieces on
	the squares it contains.
*/
// types
var NeighborType = {
  Above: {
    offset: 8
  },
  AboveLeft: {
    offset: 7
  },
  AboveRight: {
    offset: 9
  },
  Below: {
    offset: -8
  },
  BelowLeft: {
    offset: -9
  },
  BelowRight: {
    offset: -7
  },
  KnightAboveLeft: {
    offset: 15
  },
  KnightAboveRight: {
    offset: 17
  },
  KnightBelowLeft: {
    offset: -17
  },
  KnightBelowRight: {
    offset: -15
  },
  KnightLeftAbove: {
    offset: 6
  },
  KnightLeftBelow: {
    offset: -10
  },
  KnightRightAbove: {
    offset: 10
  },
  KnightRightBelow: {
    offset: -6
  },
  Left: {
    offset: -1
  },
  Right: {
    offset: 1
  }
}; // ctor

exports.NeighborType = NeighborType;

var Board =
/*#__PURE__*/
function (_EventEmitter) {
  (0, _inherits2.default)(Board, _EventEmitter);

  function Board(squares) {
    var _this;

    (0, _classCallCheck2.default)(this, Board);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Board).call(this));
    _this.squares = squares;
    return _this;
  }

  (0, _createClass2.default)(Board, [{
    key: "getNeighborSquare",
    value: function getNeighborSquare(sq, n) {
      if (sq && n) {
        // validate boundaries of board
        if (sq.file === 'a' && (n === NeighborType.AboveLeft || n === NeighborType.BelowLeft || n === NeighborType.Left)) {
          return null;
        }

        if (sq.file === 'h' && (n === NeighborType.AboveRight || n === NeighborType.BelowRight || n === NeighborType.Right)) {
          return null;
        }

        if (sq.rank === 1 && (n === NeighborType.Below || n === NeighborType.BelowLeft || n === NeighborType.BelowRight)) {
          return null;
        }

        if (sq.rank === 8 && (n === NeighborType.Above || n === NeighborType.AboveLeft || n === NeighborType.AboveRight)) {
          return null;
        } // validate file


        var fIndex = 'abcdefgh'.indexOf(sq.file),
            i = 0;

        if (fIndex !== -1 && sq.rank > 0 && sq.rank < 9) {
          // find the index
          i = 8 * (sq.rank - 1) + fIndex + n.offset;

          if (this.squares && this.squares.length > i && i > -1) {
            return this.squares[i];
          }
        }
      }

      return null;
    }
  }, {
    key: "getSquare",
    value: function getSquare(f, r) {
      // check for shorthand
      if (typeof f === 'string' && f.length === 2 && !r) {
        r = (0, _parseInt2.default)(f.charAt(1), 10);
        f = f.charAt(0);
      } // validate file


      var fIndex = 'abcdefgh'.indexOf(f),
          i = 0;

      if (fIndex !== -1 && r > 0 && r < 9) {
        // Find the index
        i = 8 * (r - 1) + fIndex;

        if (this.squares && this.squares.length > i) {
          return this.squares[i];
        }
      }

      return null;
    }
  }, {
    key: "getSquares",
    value: function getSquares(side) {
      var i = 0,
          list = [];

      for (i = 0; i < this.squares.length; i++) {
        if (this.squares[i].piece && this.squares[i].piece.side === side) {
          list.push(this.squares[i]);
        }
      }

      return list;
    }
  }, {
    key: "move",
    value: function move(src, dest, n) {
      if (typeof src === 'string' && src.length === 2) {
        src = this.getSquare(src);
      }

      if (typeof dest === 'string' && dest.length === 2) {
        dest = this.getSquare(dest);
      }

      var simulate = false;

      if (typeof n === 'boolean') {
        simulate = n;
        n = null;
      }

      if (src && src.file && src.rank && dest && dest.file && dest.rank) {
        var move = {
          algebraic: n,
          capturedPiece: dest.piece,
          castle: false,
          enPassant: false,
          postSquare: dest,
          prevSquare: src
        },
            p = src.piece,
            sq = null,
            undo = function undo(b, m) {
          return function () {
            m.prevSquare.piece = m.postSquare.piece;
            m.postSquare.piece = m.capturedPiece;

            if (!m.enPassant) {
              m.postSquare.piece = m.capturedPiece;
            } else {
              b.getSquare(m.postSquare.file, m.prevSquare.rank).piece = m.capturedPiece; // there is no piece on the post square in the event of
              // an en-passant, clear anything that me be present as
              // a result of the move (fix for issue #8)

              m.postSquare.piece = null;
            }

            if (m.castle) {
              sq = b.getSquare(move.postSquare.file === 'g' ? 'f' : 'd', move.postSquare.rank);
              b.getSquare(move.postSquare.file === 'g' ? 'h' : 'a', move.postSquare.rank).piece = sq.piece;
              sq.piece = null;
            }
          };
        };

        dest.piece = p;
        move.castle = p.type === _piece.PieceType.King && p.moveCount === 0 && (move.postSquare.file === 'g' || move.postSquare.file === 'c');
        move.enPassant = p.type === _piece.PieceType.Pawn && move.capturedPiece === null && move.postSquare.file !== move.prevSquare.file;
        move.prevSquare.piece = null; // check for en-passant

        if (move.enPassant) {
          sq = this.getSquare(move.postSquare.file, move.prevSquare.rank);
          move.capturedPiece = sq.piece;
          sq.piece = null;
        } // check for castle


        if (move.castle) {
          sq = this.getSquare(move.postSquare.file === 'g' ? 'h' : 'a', move.postSquare.rank);

          if (sq.piece === null) {
            move.castle = false;
          } else {
            this.getSquare(move.postSquare.file === 'g' ? 'f' : 'd', move.postSquare.rank).piece = sq.piece;
            sq.piece = null;
          }
        }

        if (!simulate) {
          p.moveCount++;
          this.lastMovedPiece = p;
          this.emit('move', move);
        }

        return {
          move: move,
          undo: undo(this, move, simulate)
        };
      }
    }
  }, {
    key: "promote",
    value: function promote(sq, p) {
      // update move count and last piece
      p.moveCount = sq.piece.moveCount;
      this.lastMovedPiece = p; // set to square

      sq.piece = p;
      this.emit('promote', sq);
      return sq;
    }
  }], [{
    key: "create",
    value: function create() {
      var b = new Board([]),
          f = 0,
          i = 0,
          r = 0,
          sq = null;
      /* eslint no-magic-numbers:0 */

      for (i = 0; i < 64; i++) {
        f = Math.floor(i % 8);
        r = Math.floor(i / 8) + 1;
        sq = _square.Square.create('abcdefgh'[f], r);
        b.squares.push(sq);

        if (r === 1 || r === 8) {
          // Named pieces
          if (f === 0 || f === 7) {
            // Rookage
            sq.piece = _piece.Piece.createRook(r === 1 ? _piece.SideType.White : _piece.SideType.Black);
          } else if (f === 1 || f === 6) {
            // Knights
            sq.piece = _piece.Piece.createKnight(r === 1 ? _piece.SideType.White : _piece.SideType.Black);
          } else if (f === 2 || f === 5) {
            // Bish's
            sq.piece = _piece.Piece.createBishop(r === 1 ? _piece.SideType.White : _piece.SideType.Black);
          } else if (f === 3) {
            sq.piece = _piece.Piece.createQueen(r === 1 ? _piece.SideType.White : _piece.SideType.Black);
          } else {
            sq.piece = _piece.Piece.createKing(r === 1 ? _piece.SideType.White : _piece.SideType.Black);
          }
        } else if (r === 2 || r === 7) {
          // Pawns
          sq.piece = _piece.Piece.createPawn(r === 2 ? _piece.SideType.White : _piece.SideType.Black);
        }
      }

      return b;
    }
  }]);
  return Board;
}(_events.EventEmitter); // exports


exports.Board = Board;
var _default = {
  Board: Board,
  NeighborType: NeighborType
};
exports.default = _default;
//# sourceMappingURL=board.js.map
