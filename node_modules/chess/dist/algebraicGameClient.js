"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AlgebraicGameClient = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _piece = require("./piece");

var _events = require("events");

var _game = require("./game");

var _gameValidation = require("./gameValidation");

// private methods
function getNotationPrefix(src, dest, movesForPiece) {
  var containsDest = function containsDest(squares) {
    var n = 0;

    for (n = 0; n < squares.length; n++) {
      if (squares[n] === dest) {
        return true;
      }
    }

    return false;
  },
      file = '',
      fileHash = {},
      i = 0,
      prefix = src.piece.notation,
      rank = 0,
      rankHash = {};

  for (i = 0; i < movesForPiece.length; i++) {
    if (containsDest(movesForPiece[i].squares)) {
      file = movesForPiece[i].src.file;
      rank = movesForPiece[i].src.rank;
      fileHash[file] = typeof fileHash[file] !== 'undefined' ? fileHash[file] + 1 : 1;
      rankHash[rank] = typeof rankHash[rank] !== 'undefined' ? rankHash[rank] + 1 : 1;
    }
  }

  if ((0, _keys.default)(fileHash).length > 1) {
    prefix += src.file;
  }

  if ((0, _keys.default)(rankHash).length > (0, _keys.default)(fileHash).length) {
    prefix += src.rank;
  }

  return prefix;
}

function getValidMovesByPieceType(pieceType, validMoves) {
  var byPiece = [],
      i = 0;

  for (i = 0; i < validMoves.length; i++) {
    if (validMoves[i].src.piece.type === pieceType) {
      byPiece.push(validMoves[i]);
    }
  }

  return byPiece;
}

function notate(validMoves, gameClient) {
  var algebraicNotation = {},
      i = 0,
      isPromotion = false,
      movesForPiece = [],
      n = 0,
      p = null,
      prefix = '',
      sq = null,
      suffix = ''; // iterate through each starting squares valid moves

  for (i = 0; i < validMoves.length; i++) {
    p = validMoves[i].src.piece; // iterate each potential move and build prefix and suffix for notation

    for (n = 0; n < validMoves[i].squares.length; n++) {
      prefix = '';
      sq = validMoves[i].squares[n]; // set suffix for notation

      suffix = (sq.piece ? 'x' : '') + sq.file + sq.rank; // check for potential promotion

      /* eslint no-magic-numbers: 0 */

      isPromotion = (sq.rank === 8 || sq.rank === 1) && p.type === _piece.PieceType.Pawn; // squares with pawns

      if (sq.piece && p.type === _piece.PieceType.Pawn) {
        prefix = validMoves[i].src.file;
      } // squares with Bishop, Knight, Queen or Rook pieces


      if (p.type === _piece.PieceType.Bishop || p.type === _piece.PieceType.Knight || p.type === _piece.PieceType.Queen || p.type === _piece.PieceType.Rook) {
        // if there is more than 1 of the specified piece on the board,
        // can more than 1 land on the specified square?
        movesForPiece = getValidMovesByPieceType(p.type, validMoves);

        if (movesForPiece.length > 1) {
          prefix = getNotationPrefix(validMoves[i].src, sq, movesForPiece);
        } else {
          prefix = validMoves[i].src.piece.notation;
        }
      } // squares with a King piece


      if (p.type === _piece.PieceType.King) {
        // look for castle left and castle right
        if (validMoves[i].src.file === 'e' && sq.file === 'g') {
          // fix for issue #13 - if PGN is specified should be letters, not numbers
          prefix = gameClient.PGN ? 'O-O' : '0-0';
          suffix = '';
        } else if (validMoves[i].src.file === 'e' && sq.file === 'c') {
          // fix for issue #13 - if PGN is specified should be letters, not numbers
          prefix = gameClient.PGN ? 'O-O-O' : '0-0-0';
          suffix = '';
        } else {
          prefix = validMoves[i].src.piece.notation;
        }
      } // set the notation


      if (isPromotion) {
        // Rook promotion
        algebraicNotation[prefix + suffix + 'R'] = {
          dest: sq,
          src: validMoves[i].src
        }; // Knight promotion

        algebraicNotation[prefix + suffix + 'N'] = {
          dest: sq,
          src: validMoves[i].src
        }; // Bishop promotion

        algebraicNotation[prefix + suffix + 'B'] = {
          dest: sq,
          src: validMoves[i].src
        }; // Queen promotion

        algebraicNotation[prefix + suffix + 'Q'] = {
          dest: sq,
          src: validMoves[i].src
        };
      } else {
        algebraicNotation[prefix + suffix] = {
          dest: sq,
          src: validMoves[i].src
        };
      }
    }
  }

  return algebraicNotation;
}

function parseNotation(notation) {
  var parseDest = ''; // try and parse the notation

  parseDest = notation.substring(notation.length - 2);

  if (notation.length > 2) {
    return notation.charAt(0) + parseDest;
  }

  return '';
}

function updateGameClient(gameClient) {
  gameClient.validation.start(function (err, result) {
    if (err) {
      throw new Error(err);
    }

    gameClient.isCheck = result.isCheck;
    gameClient.isCheckmate = result.isCheckmate;
    gameClient.isRepetition = result.isRepetition;
    gameClient.isStalemate = result.isStalemate;
    gameClient.notatedMoves = notate(result.validMoves, gameClient);
    gameClient.validMoves = result.validMoves;
  });
}

var AlgebraicGameClient =
/*#__PURE__*/
function (_EventEmitter) {
  (0, _inherits2.default)(AlgebraicGameClient, _EventEmitter);

  function AlgebraicGameClient(game, opts) {
    var _this;

    (0, _classCallCheck2.default)(this, AlgebraicGameClient);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(AlgebraicGameClient).call(this));
    _this.game = game;
    _this.isCheck = false;
    _this.isCheckmate = false;
    _this.isRepetition = false;
    _this.isStalemate = false;
    _this.notatedMoves = {}; // for issue #13, adding options allowing consumers to specify
    // PGN (Portable Game Notation)... essentially, this makes castle moves
    // appear as capital letter O rather than the number 0

    _this.PGN = opts && typeof opts.PGN === 'boolean' ? opts.PGN : false;
    _this.validMoves = [];
    _this.validation = _gameValidation.GameValidation.create(_this.game); // bubble the game check event

    _this.game.on('check', function (attackers) {
      return _this.emit('check', attackers);
    });

    return _this;
  }

  (0, _createClass2.default)(AlgebraicGameClient, [{
    key: "getStatus",
    value: function getStatus(forceUpdate) {
      if (forceUpdate) {
        updateGameClient(this);
      }

      return {
        board: this.game.board,
        isCheck: this.isCheck,
        isCheckmate: this.isCheckmate,
        isRepetition: this.isRepetition,
        isStalemate: this.isStalemate,
        notatedMoves: this.notatedMoves
      };
    }
  }, {
    key: "move",
    value: function move(notation, isFuzzy) {
      var move = null,
          notationRegex = /^[BKQNR]?[a-h]?[1-8]?[x-]?[a-h][1-8][+#]?$/,
          p = null,
          promo = '',
          side = this.game.getCurrentSide();

      if (notation && typeof notation === 'string') {
        // clean notation of extra or alternate chars
        notation = notation.replace(/\!/g, '').replace(/\+/g, '').replace(/\#/g, '').replace(/\=/g, '').replace(/\\/g, ''); // fix for issue #13 - if PGN is specified, should be letters not numbers

        if (this.PGN) {
          notation = notation.replace(/0/g, 'O');
        } else {
          notation = notation.replace(/O/g, '0');
        } // check for pawn promotion


        if (notation.charAt(notation.length - 1).match(/[BNQR]/)) {
          promo = notation.charAt(notation.length - 1);
        } // use it directly or attempt to parse it if not found


        if (this.notatedMoves[notation]) {
          move = this.game.board.move(this.notatedMoves[notation].src, this.notatedMoves[notation].dest, notation);
        } else if (notation.match(notationRegex) && notation.length > 1 && !isFuzzy) {
          return this.move(parseNotation(notation), true);
        } else if (isFuzzy) {
          throw new Error("Invalid move (".concat(notation, ")"));
        }

        if (move) {
          // apply pawn promotion
          if (promo) {
            switch (promo) {
              case 'B':
                p = _piece.Piece.createBishop(side);
                break;

              case 'N':
                p = _piece.Piece.createKnight(side);
                break;

              case 'Q':
                p = _piece.Piece.createQueen(side);
                break;

              case 'R':
                p = _piece.Piece.createRook(side);
                break;

              default:
                p = _piece.Piece.createPawn(side);
            }

            if (p) {
              this.game.board.promote(move.move.postSquare, p);
              /*
              p.moveCount = move.move.postSquare.piece.moveCount;
              move.move.postSquare.piece = p;
              //*/
            }
          }

          updateGameClient(this);
          return move;
        }
      }

      throw new Error("Notation is invalid (".concat(notation, ")"));
    }
  }], [{
    key: "create",
    value: function create(opts) {
      var game = _game.Game.create(),
          gameClient = new AlgebraicGameClient(game, opts);

      updateGameClient(gameClient);
      return gameClient;
    }
  }]);
  return AlgebraicGameClient;
}(_events.EventEmitter);

exports.AlgebraicGameClient = AlgebraicGameClient;
var _default = {
  AlgebraicGameClient: AlgebraicGameClient
};
exports.default = _default;
//# sourceMappingURL=algebraicGameClient.js.map
