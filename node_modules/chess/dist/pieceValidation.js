"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.RookValidation = exports.QueenValidation = exports.PawnValidation = exports.KnightValidation = exports.KingValidation = exports.BishopValidation = exports.PieceValidation = void 0;

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _piece = require("./piece");

var _board = require("./board");

/**
	The general idea behind PieceValidation is to examine an individual piece
	and determine (with the information available from about that single piece)
	what move options are available for that piece.

	The PieceValidation doesn't alter any properties of the piece, the board
	or any squares. Additionally, the PieceValidation is suitable for 1 phase of
	the evaluation of viable move options for a piece... the BoardValidation
	component handles the overall evaluation of what moves are possible for the
	board in its current state.
*/
var PieceValidation =
/*#__PURE__*/
function () {
  function PieceValidation(board) {
    (0, _classCallCheck2.default)(this, PieceValidation);
    this.allowBackward = false;
    this.allowDiagonal = false;
    this.allowForward = false;
    this.allowHorizontal = false;
    this.board = board;
    this.type = null;
    this.repeat = 0;
  }

  (0, _createClass2.default)(PieceValidation, [{
    key: "applySpecialValidation",
    value: function applySpecialValidation() {// do nothing...
      // overridden in the concrete validation classes
      // where special logic is required
    }
  }, {
    key: "start",
    value: function start(src, callback) {
      // ensure callback is set
      callback = callback || function (err, destinationSquares) {
        return new _promise.default(function (resolve, reject) {
          if (err) {
            return reject(err);
          }

          return resolve(destinationSquares);
        });
      };

      var opt = {
        destSquares: [],
        origin: src,
        piece: src ? src.piece : null
      };

      var findMoveOptions = function findMoveOptions(b, r, n) {
        var block = false,
            capture = false,
            currentSquare = b.getNeighborSquare(opt.origin, n),
            i = 0;

        while (currentSquare && i < r) {
          block = currentSquare.piece !== null && (opt.piece.type === _piece.PieceType.Pawn || currentSquare.piece.side === opt.piece.side);
          capture = currentSquare.piece && !block;

          if (!block) {
            opt.destSquares.push(currentSquare);
          }

          if (capture || block) {
            currentSquare = null;
          } else {
            currentSquare = b.getNeighborSquare(currentSquare, n);
            i++;
          }
        }
      };

      if (!opt.piece || opt.piece.type !== this.type) {
        return callback(new Error('piece is invalid'));
      }

      if (this.board && opt.origin) {
        // forward squares
        if (this.allowForward) {
          findMoveOptions(this.board, this.repeat, opt.piece.side === _piece.SideType.White ? _board.NeighborType.Above : _board.NeighborType.Below);
        } // backward squares


        if (this.allowBackward) {
          findMoveOptions(this.board, this.repeat, opt.piece.side === _piece.SideType.White ? _board.NeighborType.Below : _board.NeighborType.Above);
        } // horizontal squares


        if (this.allowHorizontal) {
          findMoveOptions(this.board, this.repeat, _board.NeighborType.Left);
          findMoveOptions(this.board, this.repeat, _board.NeighborType.Right);
        } // diagonal squares


        if (this.allowDiagonal) {
          findMoveOptions(this.board, this.repeat, _board.NeighborType.AboveLeft);
          findMoveOptions(this.board, this.repeat, _board.NeighborType.BelowRight);
          findMoveOptions(this.board, this.repeat, _board.NeighborType.BelowLeft);
          findMoveOptions(this.board, this.repeat, _board.NeighborType.AboveRight);
        } // apply additional validation logic


        this.applySpecialValidation(opt); // callback

        return callback(null, opt.destSquares);
      }

      return callback(new Error('board is invalid'));
    }
  }], [{
    key: "create",
    value: function create(piece, board) {
      switch (piece) {
        case _piece.PieceType.Bishop:
          return new BishopValidation(board);

        case _piece.PieceType.King:
          return new KingValidation(board);

        case _piece.PieceType.Knight:
          return new KnightValidation(board);

        case _piece.PieceType.Pawn:
          return new PawnValidation(board);

        case _piece.PieceType.Queen:
          return new QueenValidation(board);

        case _piece.PieceType.Rook:
          return new RookValidation(board);

        default:
          return null;
      }
    }
  }]);
  return PieceValidation;
}();

exports.PieceValidation = PieceValidation;

var BishopValidation =
/*#__PURE__*/
function (_PieceValidation) {
  (0, _inherits2.default)(BishopValidation, _PieceValidation);

  function BishopValidation(board) {
    var _this;

    (0, _classCallCheck2.default)(this, BishopValidation);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(BishopValidation).call(this, board)); // base validation properties

    _this.allowDiagonal = true;
    _this.type = _piece.PieceType.Bishop;
    _this.repeat = 8;
    return _this;
  }

  return BishopValidation;
}(PieceValidation);

exports.BishopValidation = BishopValidation;

var KingValidation =
/*#__PURE__*/
function (_PieceValidation2) {
  (0, _inherits2.default)(KingValidation, _PieceValidation2);

  function KingValidation(board) {
    var _this2;

    (0, _classCallCheck2.default)(this, KingValidation);
    _this2 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KingValidation).call(this, board)); // base validation properties

    _this2.allowBackward = true;
    _this2.allowDiagonal = true;
    _this2.allowForward = true;
    _this2.allowHorizontal = true;
    _this2.type = _piece.PieceType.King;
    _this2.repeat = 1;
    return _this2;
  }

  (0, _createClass2.default)(KingValidation, [{
    key: "applySpecialValidation",
    value: function applySpecialValidation() {// check for castle?
    }
  }]);
  return KingValidation;
}(PieceValidation);

exports.KingValidation = KingValidation;

var KnightValidation =
/*#__PURE__*/
function (_PieceValidation3) {
  (0, _inherits2.default)(KnightValidation, _PieceValidation3);

  function KnightValidation(board) {
    var _this3;

    (0, _classCallCheck2.default)(this, KnightValidation);
    _this3 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KnightValidation).call(this, board)); // base validation properties

    _this3.type = _piece.PieceType.Knight;
    _this3.repeat = 1;
    return _this3;
  }

  (0, _createClass2.default)(KnightValidation, [{
    key: "applySpecialValidation",
    value: function applySpecialValidation(opt) {
      // add knight move options
      var aboveLeft = this.board.getNeighborSquare(opt.origin, _board.NeighborType.AboveLeft),
          aboveRight = this.board.getNeighborSquare(opt.origin, _board.NeighborType.AboveRight),
          belowLeft = this.board.getNeighborSquare(opt.origin, _board.NeighborType.BelowLeft),
          belowRight = this.board.getNeighborSquare(opt.origin, _board.NeighborType.BelowRight),
          i = 0,
          p = null,
          squares = [];

      if (aboveLeft) {
        squares.push(this.board.getNeighborSquare(aboveLeft, _board.NeighborType.Above));
        squares.push(this.board.getNeighborSquare(aboveLeft, _board.NeighborType.Left));
      }

      if (aboveRight) {
        squares.push(this.board.getNeighborSquare(aboveRight, _board.NeighborType.Above));
        squares.push(this.board.getNeighborSquare(aboveRight, _board.NeighborType.Right));
      }

      if (belowLeft) {
        squares.push(this.board.getNeighborSquare(belowLeft, _board.NeighborType.Below));
        squares.push(this.board.getNeighborSquare(belowLeft, _board.NeighborType.Left));
      }

      if (belowRight) {
        squares.push(this.board.getNeighborSquare(belowRight, _board.NeighborType.Below));
        squares.push(this.board.getNeighborSquare(belowRight, _board.NeighborType.Right));
      }

      for (i = 0; i < squares.length; i++) {
        if (squares[i]) {
          // check for enemy piece on square
          p = squares[i] ? squares[i].piece : null;

          if (!p || p.side !== opt.piece.side) {
            opt.destSquares.push(squares[i]);
          }
        }
      }
    }
  }]);
  return KnightValidation;
}(PieceValidation);

exports.KnightValidation = KnightValidation;

var PawnValidation =
/*#__PURE__*/
function (_PieceValidation4) {
  (0, _inherits2.default)(PawnValidation, _PieceValidation4);

  function PawnValidation(board) {
    var _this4;

    (0, _classCallCheck2.default)(this, PawnValidation);
    _this4 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PawnValidation).call(this, board)); // base validation properties

    _this4.allowForward = true;
    _this4.type = _piece.PieceType.Pawn;
    _this4.repeat = 1;
    return _this4;
  }
  /* eslint no-magic-numbers:0 */


  (0, _createClass2.default)(PawnValidation, [{
    key: "applySpecialValidation",
    value: function applySpecialValidation(opt) {
      // check for capture
      var i = 0,
          p = null,
          sq = null,
          squares = [this.board.getNeighborSquare(opt.origin, opt.piece.side === _piece.SideType.White ? _board.NeighborType.AboveLeft : _board.NeighborType.BelowLeft), this.board.getNeighborSquare(opt.origin, opt.piece.side === _piece.SideType.White ? _board.NeighborType.AboveRight : _board.NeighborType.BelowRight)]; // check for capture

      for (i = 0; i < squares.length; i++) {
        // check for enemy piece on square
        p = squares[i] ? squares[i].piece : null;

        if (p && p.side !== opt.piece.side) {
          opt.destSquares.push(squares[i]);
        }
      } // check for double square first move


      if (opt.piece.moveCount === 0 && opt.destSquares.length && // Fix for issue #15 (originally looked for length of 1)
      opt.destSquares[0].piece === null) {
        // Fix for issue #1
        sq = this.board.getNeighborSquare(opt.destSquares[0], opt.piece.side === _piece.SideType.White ? _board.NeighborType.Above : _board.NeighborType.Below);

        if (!sq.piece) {
          opt.destSquares.push(sq);
        } // check for en passant

      } else if (opt.origin.rank === (opt.piece.side === _piece.SideType.White ? 5 : 4)) {
        // get squares left & right of pawn
        squares = [this.board.getNeighborSquare(opt.origin, _board.NeighborType.Left), this.board.getNeighborSquare(opt.origin, _board.NeighborType.Right)];
        i = 0;

        for (i = 0; i < squares.length; i++) {
          // check for pawn on square
          p = squares[i] ? squares[i].piece : null;

          if (p && p.type === _piece.PieceType.Pawn && p.side !== opt.piece.side && p.moveCount === 1 && this.board.lastMovedPiece === p) {
            opt.destSquares.push(this.board.getNeighborSquare(squares[i], p.side === _piece.SideType.Black ? _board.NeighborType.Above : _board.NeighborType.Below));
          }
        }
      }
    }
  }]);
  return PawnValidation;
}(PieceValidation);

exports.PawnValidation = PawnValidation;

var QueenValidation =
/*#__PURE__*/
function (_PieceValidation5) {
  (0, _inherits2.default)(QueenValidation, _PieceValidation5);

  function QueenValidation(board) {
    var _this5;

    (0, _classCallCheck2.default)(this, QueenValidation);
    _this5 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(QueenValidation).call(this, board)); // base validation properties

    _this5.allowBackward = true;
    _this5.allowDiagonal = true;
    _this5.allowForward = true;
    _this5.allowHorizontal = true;
    _this5.repeat = 8;
    _this5.type = _piece.PieceType.Queen;
    return _this5;
  }

  return QueenValidation;
}(PieceValidation);

exports.QueenValidation = QueenValidation;

var RookValidation =
/*#__PURE__*/
function (_PieceValidation6) {
  (0, _inherits2.default)(RookValidation, _PieceValidation6);

  function RookValidation(board) {
    var _this6;

    (0, _classCallCheck2.default)(this, RookValidation);
    _this6 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(RookValidation).call(this, board)); // base validation properties

    _this6.allowBackward = true;
    _this6.allowForward = true;
    _this6.allowHorizontal = true;
    _this6.repeat = 8;
    _this6.type = _piece.PieceType.Rook;
    return _this6;
  }

  return RookValidation;
}(PieceValidation);

exports.RookValidation = RookValidation;
var _default = {
  PieceValidation: PieceValidation
};
exports.default = _default;
//# sourceMappingURL=pieceValidation.js.map
